
浏览器缓存和数据压缩
HTTP缓存机制
Nginx配置缓存策略
前端代码和资源的压缩
高并发下只能通过提升服务器负载解决
缓存只能做数据库缓存吗

启用浏览器缓存
缓存分类
HTTP缓存模型中 如果请求成功会有三种情况
200 from cache 直接从本地缓存中获取响应 最快速 最省流量 因为根本没有向服务业器发送请求

304 Not Modified 协商缓存 浏览器在本地没有命中的情况下请求头中发送一定的校验数据到服务端 如果服务端数据没有改变浏览器从本地缓存响应 返回304
快速 发送的数据很少 只返回一些基本的响应头信息 数据量很小 不发送实际响应体

200 OK 以上两种缓存全都失败 服务器返回完整响应 没有用到缓存 相对最慢

浏览器认为本地缓存可以使用 不会去请求服务端

相关Header Pragma HTTP1时代的遗留产物 该字段被设置为no-cache时 会告知浏览器禁用本地缓存 即每次都向服务器发送请求
Expires HTTP1 时代用来启用本地缓存的字段 expires值对应一个形如Thu 31 Dec 2037 23:55:55 GMT的格林威治时间 告诉浏览器缓存实现的时刻 如果还没到该时刻 标明缓存有效无需发送请求
浏览器与服务器的时间无法保持一致 如果时间差距大 就会影响缓存结果
Cache-Control HTTP1.1针对Expires时间不一致的解决方案 运用Cache-Control告知浏览器缓存过期的时间间隔而不是时刻 即使具体时间不一致 也不影响缓存的管理
no-store 禁止浏览器缓存响应
no-cache 不允许直接使用本地缓存 先发起请求和服务器协商
max-age=delta-seconds 告知浏览器该响应本地缓存有效的最长期限期 以秒为单位
优先级 Pragma > Cache-Control > Expires
Last-Modified 通知浏览器资源的最后修改时间
Last-Modified:Mon,28 Sep 2015 08:06:43 GMT
If-Modified-Since 得到资源的最后修改时间后 会将这个信息通过If-Modified-Since提交到服务器做检查 如果没有修改 返回304状态码
If-Modified-Since:Mon,28 Sep 2015 08:06:43 GMT
ETag HTTP1.1推出 文件的指纹标识符 如果文件内容修改 指纹会改变
If-None-Match 本地缓存失效 会携带此值去请求服务端 服务端判断该资源是否改变 如果没有改变 直接使用本地缓存 返回304

适合缓存的内容
不变的图像 如logo 图标等
js css 静态文件
可下载的内容 媒体文件

建议使用协商缓存
HTML文件
经常替换的图片
经常修改的js css文件
js css文件的加载可以加入文件的签名来拒绝缓存
不建议缓存的内容 用户隐私等敏感数据
经常改变的api数据接口

<?php

/**
    2009.11 新浪云计算
    2010.05 SAE 公有云平台开放注册
    2011.08 第一个重量级应用案例
    2012.03 云商店
    2012.07 企业云服务
    2014.05 掌上SAE
    2014.06 新浪云存储
    2014.10 MAE 私有云解决方案

    运行环境的一些限制
    变相本地读写
    不允许绑定端口
    限制了一些函数和类
    ini_set 使用白名单机制

    应用之间的隔离
    代码层面的隔离
    第一层 PHP Sandbox
    第二层 Linux Container
    第三层 Apache Sandbox

    网络层面的隔离
    转发 L7 到 FetchURL
    转发 L4 到 SocketProxy

    代码的迁移
    使用权 stream wrapper 代理本地的文件读写操作
    saekv://
    saemc://
    saestor://

    上传的文件需要存储到storage 或者去存储中
    使用到 Memcache 的部分只用把连接的 ip:port 任意指定即可
    留意应用的错误日志是否有 warning 解决 warning

    sae 代码部署原理图
    创建应用 (自动初始化) ---> SVN 仓库 ---> 部署代码 svn co & ci
                                  |
                           代码分发 (Web runtime) 验证

    管理员  参与者 观察者 自定义
    灵活分配团队成员 管理代码 管理服务 设置配额 设置应用信息权限

    自带调优工具
    管理后台一键开启
    由函数 sae_xhprof_start() 和 sae_xhprof_end() 自行控制调试开关

    支持定时任务 异步任务
    SAE 提供粒度最低到分钟的分布式定时任务
    Cron 的执行是以 HTTP 方式触发的 触发后真正执行的是用户在应用的 HTTP 的回调函数
    Cron 服务是分布式环境部署的 具有高可靠性 多点之间相互隔离且同时触发 并且通过分布式锁进行选举并最终由一个健康节点执行
    SAE 也提供分布式任务队列服务 用于执行异步的 HTTP 调用方式的任务
    提供阻塞度长的顺序队列和并发度高的并发队列

    长时间的cron
    max_execution_time 不够用怎么办
    SAE 将 Cron 和 WebRuntime 进行分离
    允许执行 cron 的脚本最长运行30 分钟

    SAE 本身提供多层次的底层沙箱机制 保证应用的安全
    紧随 PHP 官方的版本 及时更新小版本

    应用防火墙
    应用防火墙是运行在 SAE 负载均衡处的过滤模块 实现对恶意抓取的行为有效拦截

    黑白名单机制
    频率 / 流量限制机制
    访问速度限制机制

    低成本的使用 CDN 服务
    一键开启
    实现对网站中的静态资源和云存储中的静态文件的加速
    只需按正常的方式进行部署 即可将资源部署至 CDN 源站 然后SAE 的 CDN 服务会自动将资源同步至各个节点 随后您的用户在访问资源时 将就近获取 从而获得更好的访问体验
    能过 CDN 服务产生的流量相对较使用 会为您节约 30% 左右的流量费

    PHP 实现密集型计算
    写 PHP 脚本 以进程的方式运行
    在多台机器上都运行这个脚本
    实现一种机制防止竞争发生 避免计算资源浪费
    存在一些缺点
    这种调度机制不是很容易部署
    很难 控某台机器的某一个进程还在不在
    不具有通用性 换一种计算模型还得重头来过

    在 SAE 由 PHP 实现密集型的计算
    本身实现是无锁的 任务的分配由 Cron 完成 插入到按任务 hash 的 TaskQueue 中
    TaskQueue 并发度由 TaskQueue 的总数和单个 TaskQueue 的并发度乘积得出
    计算节点无状态 执行结果可以更新到 NoSQL 中或者分表存储可以避免压力

    常规的快速上线和回滚方式
    通过 RPM 包的方式 给新包和回滚备份包 出问题时立马用旧的包覆盖
    通过 git 或者 svn hook 的方式 用代码控制器的方式回滚
    其他方式

    存在的问题
    还是有个操作的时间 有时太紧急会出乱子
    造一个测试的环境可能成本巨大 特别是系统的组件很多很多的时候
*/



